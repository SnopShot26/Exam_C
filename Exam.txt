Платформа .Net
1) Что такое платформа .Net? 
{
 Когда говорят C#, нередко имеют в виду технологии платформы .NET (Windows Forms, WPF, ASP.NET, Xamarin). 
 И, наоборот, когда говорят .NET, нередко имеют в виду C#. Однако, хотя эти понятия связаны, отождествлять их неверно. 
 Язык C# был создан специально для работы с фреймворком .NET, однако само понятие .NET несколько шире
 *Поддержка нескольких языков
 *Кроссплатформенность.
 *Мощная библиотека классов
 *Производительность
}
2) В чем разница между .Net Framework и .Net Core?
{
 .NET Core работает в Linux и macOS, а .NET Framework работает только в Windows. 
 Вы бы использовали .NET Core, когда вам нужна кросс-платформенная совместимость, и вы бы использовали .NET Framework, 
 когда вам нужны специальные службы Windows и пакеты NuGet, которые не были перенесены в .NET Core. 
}
3) В чем заключаются основные отличия C# и C++?
4) Как отличается процесс компиляции и выполнения программы, написанной на C++ и C#?
5) Какие языки входят в .Net?
{
 наряду с C# это также VB.NET, C++, F#, 
 а также различные диалекты других языков, привязанные к .NET, например, Delphi.NET.
}
6) Из каких основных компонентов состоит .Net?
7) В чем заключаются преимущества .Net перед C++?
8) В чем заключаются недостатки .Net перед C++?
9) Что такое CLR (Common Language Runtime)?
{
  NET предоставляет среду выполнения (среду CLR), 
  которая выполняет код и предлагает службы, облегчающие процесс разработки.
  Компиляторы и иные средства позволяют использовать функции среды CLR и дают 
  разработчикам возможность писать код, использующий преимущества этой среды управляемого  выполнения. 
  Код,разработанный с использованием языкового компилятора для среды выполнения, называют управляемым. 
  В нем используются преимущества таких средств, как объединение языков  программирования, объединенная обработка исключений, усиленная безопасность, 
  поддержка отслеживания версий и развертывания, упрощенная модель взаимодействия компонентов, а также службы отладки и профилирования.
  
}
10) Что такое JIT (Just In Time) Compiler?
{
  это модуль в CLR который переводит IL-COD в машинный код;
}
11) Что такое GC (Garbage Collector)?
{
   Мусорщик который подчищает за нами;
}
12) Что такое BCL (Base Class Library) / FCL (Framework Class Library)?
{
  Base Class Library, или так называемая .NET FCL (англ. Framework Class Library), сокращённо BCL — стандартная библиотека классов платформы «.NET Framework».
  Программы,   написанные на любом из языков, поддерживающих платформу .NET, могут
  пользоваться классами и методами BCL — создавать объекты классов, вызывать их методы, наследовать необходимые классы BCL и т. д.
  Стоит отметить, что не все языки, поддерживающие платформу .NET, предоставляют или обязаны предоставлять одинаково полный доступ ко всем 
  классам и всем возможностям BCL — это зависит от особенностей реализации конкретного компилятора и языка. 
}
13) Что такое CTS (Common Type System)?
{
  Система общих типов 
  Система общих типов CTS определяет способ объявления, использования и управления типами в среде CLR,
  а также является важной составной частью поддержки межъязыковой интеграции  в среде выполнения. Система общих типов выполняет следующие функции.
  
      Формирует инфраструктуру, которая позволяет обеспечивать межъязыковую интеграцию, безопасность типов и высокопроизводительное выполнение кода.
  
      Предоставляет объектно-ориентированную модель, поддерживающую полную реализацию многих языков программирования.
  
      Определяет правила, которых необходимо придерживаться в языке. Эти правила помогают обеспечить взаимодействие объектов, написанных на разных языках.
  
      Предоставляет библиотеку, которая содержит типы-примитивы (например, Boolean, Byte, Char, Int32 и UInt64), используемые в разработке приложений.
}
14) Что такое CLS (Common Language System)? //Спросить У Амирана
{
 набор правил для ваше языка по которым он он должен компилироватся 
}
Сборка .Net приложений
15) Что такое сборка (assembly)?
16) Что такое MS-IL (Microsoft Intermediate Language)?
{
 промижуточный язык 
}
17) Что такое манифест (manifest)?
{
 там храниться данные проекта и его настройки 
}
18) Что такое метаданные (metadata)?
{
 они хранят описание данных классов , структур 
}
19) Что такое рефлексия (reflection)?
20) Что такое рефлектор (reflector)?
{ 
 расшифровывает Il cod
}
21) Что такое дотфускатор (dotfuscator)?
{
 запутывает Il код чтобы рефлектор не мог расшифрровать
}
22) В чем отличие управляемого кода от неуправляемого кода?

Типы данных .Net
23) В чем отличие ссылочных и значимых типов данных?
24) Чем отличаются друг от друга классы и структуры?
25) Что такое object? Какие методы он содержит?
26) Что такое стек (stack), куча (heap) и управляемая куча (managed heap)?
27) Что такое анонимный тип?
28) Что такое nullable-тип?
29) В чем заключается особенности преобразования типов данных в .Net?
30) Что такое ref и out параметры? В чем между ними разница?
31) Что такое in параметр? В каких случаях стоит его применять?
32) Что такое ключевое слово params?
33) Чем enum в .Net отличается от enum в C++?
34) Что такое упаковка и распаковка (boxing and unboxing)? Почему это плохо и как
его избежать?
35) В чем разница между классами String и StringBuilder?

Классы
36) Для чего нужны спецификаторы доступа у классов?
{
 Модификаторы доступа позволяют задать допустимую область видимости для членов класса. 
 То есть модификаторы доступа определяют контекст, 
 в котором можно употреблять данную переменную или метод 
}

37) Назовите все 6 видов спецификаторов доступа членов класса. Для чего они нужны?
{
public: публичный, общедоступный класс или член класса. 
Такой член класса доступен из любого места в коде, 
а также из других программ и сборок.

private: закрытый класс или член класса. Представляет полную противоположность модификатору public. 
Такой закрытый класс или член класса доступен только из кода в том же классе или контексте.

protected: такой член класса доступен из любого места в текущем классе или в производных классах. 
При этом производные классы могут располагаться в других сборках.

internal: класс и члены класса с подобным модификатором доступны из любого места кода в той же сборке, 
однако он недоступен для других программ и сборок (как в случае с модификатором public).

protected internal: совмещает функционал двух модификаторов. 
Классы и члены класса с таким модификатором доступны из текущей сборки и из производных классов.

private protected: такой член класса доступен из любого места в текущем классе или в производных классах, 
которые определены в той же сборке.

}

38) Для чего нужен статический конструктор? Когда он вызывается?
{
 Статический конструктор вызывается автоматически для инициализации
 класса перед созданием первого экземпляра 
 типа или ссылкой на какие-либо статические члены
}

39) Что такое делегирование конструкторов?
40) Что такое частичный класс (partial class)?
41) В чем отличие между константным и readonly полем?
42) Что такое свойство (property)?
43) Что такое авто-свойство (auto-property)?
44) Что такое индексатор?
45) Что такое итератор / энумиратор?
46) Для чего нужны пространства имен (namespaces)?
47) Что такое метод-расширение (extension method)?
48) Что такое обобщения (generics)?
49) Что такое правила обобщения (generics)? Какие правила вы знаете?

Наследование и полиморфизм
50) Опишите особенности наследования в .Net.
{
 По умолчанию все классы наследуются от базового класса Object, даже если мы явным образом не устанавливаем наследование. 
 Поэтому выше определенные классы Person и Employee кроме своих собственных методов, 
 также будут иметь и методы класса Object: ToString(), Equals(), GetHashCode() и GetType().

 Все классы по умолчанию могут наследоваться. Однако здесь есть ряд ограничений:

 * Не поддерживается множественное наследование, класс может наследоваться только от одного класса.

  * При создании производного класса надо учитывать тип доступа к базовому классу - тип доступа к производному классу должен быть таким же, как и у базового класса,     или более строгим. То есть, если базовый класс у нас имеет тип доступа internal, то производный класс может иметь тип доступа internal или private, 
    но не public.

   Однако следует также учитывать, что если базовый и производный класс находятся в разных сборках (проектах), 
   то в этом случае производый класс может наследовать     
   только от класса, который имеет модификатор public.

  *Если класс объявлен с модификатором sealed, то от этого класса нельзя наследовать и создавать производные классы. 
  Например, следующий класс не допускает создание наследников:

}
51) Для чего нужно ключевое слово base?
{
 Ключевое слово base используется для доступа к членам базового из производного класса в следующих случаях:
* Вызов метода базового класса, который был переопределен другим методом.
* Определение конструктора базового класса, который должен вызываться при создании экземпляров производного класса.
}
52) Что такое запечатанный класс (sealed class)?
{ 
 Запечатанный класс нельзя использовать в качестве базового класса.
 По этой причине он также не может быть абстрактным классом. 
 Запечатанные классы предотвращают наследование. 
 Поскольку они никогда не могут использоваться в качестве базового класса, 
 некоторые оптимизации времени выполнения могут немного ускорить вызов запечатанных членов класса.
}
53) Что такое абстрактный класс (abstract class)?
{

  // абстрактный класс фигуры
  abstract class Figure
  {
    // абстрактный метод для получения периметра
    public abstract float Perimeter();
    // абстрактный метод для получения площади
    public abstract float Area();
  }
  // производный класс прямоугольника
  class Rectangle : Figure
  {
    public float Width { get; set; }
    public float Height { get; set; }
 
    public Rectangle(float width, float height)
    {
        this.Width = width;
        this.Height = height;
    }
    // переопределение получения периметра
    public override float Perimeter()
    {
        return Width * 2 + Height * 2;
    }
    // переопрелеление получения площади
    public override float Area()
    {
        return Width * Height;
    }
 } 

}
54) В чем разница между виртуальным (virtual) и абстрактным (abstract) методов?
{
 Абстрактный метод не имеет реализации. Он объявлен в родительском классе. 
 Дочерний класс отвечает за реализацию этого метода.

 Виртуальный метод должен иметь реализацию в родительском классе, и это облегчает дочернему классу выбор, 
 использовать ли эту реализацию родительского класса или иметь новую реализацию для себя для этого 
 метода в дочернем классе.

}
55) В чем разница между переопределением (overriding) и перегрузкой (overloading)?
56) В чем разница между переопределением (overriding) и замещением (new)?
{
  overriding
  public class Base
  {
    public virtual void DoIt()
    {
    }
  }

  public class Derived : Base
  {
    public override void DoIt()
    {
    }
  }

  Base b = new Derived();
  b.DoIt();                      // Calls Derived.DoIt
  Новый модификатор указывает компилятору использовать вашу реализацию дочернего класса вместо реализации родительского класса . 
  Любой код, который не является ссылка на ваш класс, но родительский класс будет использовать реализацию родительского класса .
  
   New
   public class Base
  {
    public virtual void DoIt()
    {
    }
  }

  public class Derived : Base
  {
    public new void DoIt()
    {
    }
  }

  Base b = new Derived();
  Derived d = new Derived();

  b.DoIt();                      // Calls Base.DoIt
  d.DoIt();                      // Calls Derived.DoIt
  Фактически это два совершенно разных метода, которые имеют одно и то же имя, 
  а не производный метод, переопределяющий базовый метод.
}

Исключения
57) Объясните принцип работы try, catch.
58) Для чего нужно ключевое слово finally?
{
 метод который по люоому сработает;
}
59) Что делает конструкция using?
{
 это метод который раскрываеться воть так:
      try
      {
      }
      finally
      {
       Dispos();
      }
}
60) Для чего нужно ключевые слова checked и unchecked?
{
 Ключевое слово checked используется для явного включения проверки переполнения при выполнении арифметических операций и преобразований с данными целого типа.
 По умолчанию выражение, содержащее только константные значения, вызывает ошибку компилятора в том случае, если результат
 его вычисления выходит за допустимые пределы значений  конечного типа. Если выражение содержит одно или несколько 
 неконстантных значений, компилятор не выполняет проверку переполнения. 
 Вычисление выражения, присвоенного переменной i2 в приведенном ниже примере, не вызывает ошибку компилятора.
}

Интерфейсы
61) Что такое интерфейс?
62) В чем отличие абстрактного класса от интерфейса?
63) Что допустимо создавать в интерфейсе?
64) Может ли интерфейс содержать реализацию методов?
65) Что такое интерфейсная ссылка?
66) Что такое явная реализация интерфейса?
67) Какие стандартные интерфейсы вы знаете?
68) Для чего нужен интерфейс IComparable?
69) Для чего нужен интерфейс IClonable?
70) Для чего нужен интерфейс IEnumerable?
71) Для чего нужен интерфейс IEnumerator?
72) Для чего нужен интерфейс IDisposable?
73) Для чего нужен интерфейс IEqualityComparer?

Делегаты и события

74) Что такое делегат? Для чего нужны делегаты?
{
 Делегат в C# – это тип который содержит ссылку на какой-либо метод. 
 Делегаты удобны тем, что их можно передать в метод в качестве параметра.
 В общем виде объявление типа делегата выглядит так:
 using System;

class Program {
    // объявление типа делегата
    delegate void TestDelegateType();

    static void Main() {
        // создание экземпляра делегата TestDelegateType 
        TestDelegateType testDelegateInstance = new TestDelegateType( TargetMethod );
        // вызов метода из делегата
        testDelegateInstance();

        Console.ReadKey();
    }

    // Тестовый метод для передачи делегату TestDelegateType
    static void TargetMethod()
    {
        Console.WriteLine("Вызов из делегата.");
    }    
}
}
75) Что такое событие? Для чего нужны события?
{
   это сообщение, которое возникает в различных точках исполняемого кода при выполнении определённых условий.
}
76) В чем разница между делегатом и событием?
{
 Событие нельзя запустить вне класса, в котором оно было объявлено
 Делегат объявляется вне любого класса,а	Событие объявлено внутри класса
 Делегаты не зависят от событий,а	Событие не может быть создано без делегатов.
}
77) Что делает метод Invoke?
78) Что такое анонимный метод (anonymous method)?
{
 С делегатами тесно связаны анонимные методы. Анонимные методы используются для создания экземпляров делегатов. 
 Определение анонимных методов начинается с ключевого слова delegate, после которого идет в скобках список параметров и тело метода в фигурных скобках: 

 class Program
 {
    delegate void MessageHandler(string message);
    static void Main(string[] args)
    {
        MessageHandler handler = delegate(string mes)
        {
            Console.WriteLine(mes);
        };
        handler("hello world!");
 
        Console.Read();
    }
 }

}
79) Что такое лямбда-выражение (lambda-expression)?
{
 Лямбда-выражения представляют упрощенную запись анонимных методов. Лямбда-выражения позволяют создать емкие лаконичные методы, 
 которые могут возвращать некоторое   значение и которые можно передать в качестве параметров в другие методы.

 Ламбда-выражения имеют следующий синтаксис: слева от лямбда-оператора => определяется список параметров, а справа блок выражений, использующий эти параметры: (список_параметров) => выражение. Например:
 
  class Program
 {
    delegate int Operation(int x, int y);
    static void Main(string[] args)
    {
        Operation operation = (x, y) => x + y;
        Console.WriteLine(operation(10, 20));       
        Console.WriteLine(operation(40, 20));        
        Console.Read();
    }
 }
}

Коллекции
80) Какие необобщенные (non-generic) коллекции вы знаете?
81) Какие обобщенные (generic) коллекции вы знаете?
82) В чем преимущества обобщенных (generic) коллекций над необобщенными (non-generic)?
83) В чем разница между интерфейсами IEnumerable<T> и IEnumerator<T>?
84) Что такое ObservableCollection<T>? В чем отличие от List<T>?
85) Что такое IReadOnlyCollection<T> и IReadOnlyDictionary<T>?
86) В чем разница между IEnumerable<T>, ICollection<T> и IDictionary<K, V>?
87) В каких ситуациях следует использовать List<T>, LinkedList<T>, HashSet<T>,SortedSet<T>?
88) В чем отличие Dictionary<K,V>, SortedDictionary<K,V> и SortedList<K,V>?

Сборщик мусора (Garbage Collector)
89) Объясните принцип хранения объектов в памяти.
90) Зачем нужен сборщик мусора?
91) Что такое поколения?
92) Что такое граф объектов?
93) Что такое управляемые и неуправляемые ресурсы?
{
 правляемые ресурсы в основном означают "управляемую память", управляемую сборщиком мусора. Когда у вас больше нет ссылок на управляемый объект 
 (который использует  управляемую память), сборщик мусора (в конце концов) освободит эту память для вас.

 Неуправляемые ресурсы - это все, о чем не знает сборщик мусора. Например:

 Открыть файлы
 Открыть сетевые подключения
 Неуправляемая память
 В XNA: буферы вершин, буферы индексов, текстуры и т.д.
 Обычно вы хотите освободить эти неуправляемые ресурсы, прежде чем потерять все ссылки, которые у вас есть, на объект, управляющий ими. Вы делаете это, вызывая       Dispose на этом объекте или (в С#) с помощью инструкции using, которая будет обрабатывать вызов Dispose для вас.

}
94) Что такое финализатор?
95) Для чего нужен IDisposable.Dispose?
{
 Интерфейс IDisposable объявляет один единственный метод Dispose, в котором при реализации 
 интерфейса в классе должно происходить освобождение неуправляемых ресурсов
}
96) Что сборщик мусора делает с финализируемыми объектами?
97) Какие методы сборщика мусора вы знаеме?
{
 Метод AddMemoryPressure информирует среду CLR о выделении большого объема неуправляемой памяти, которую надо учесть при планировании сборки мусора. В связке с этим   методом используется метод RemoveMemoryPressure, который указывает CLR, что ранее выделенная память освобождена, и ее не надо учитывать при сборке мусора.

 Метод Collect приводит в действие механизм сборки мусора. Перегруженные версии метода позволяют указать поколение объектов, 
 вплоть до которого надо произвести  сборку мусора

 Метод GetGeneration(Object) позволяет определить номер поколения, к которому относится переданый в качестве параметра объект

 Метод GetTotalMemory возвращает объем памяти в байтах, которое занято в управляемой куче

 Метод WaitForPendingFinalizers приостанавливает работу текущего потока до освобождения всех объектов, для которых производится сборка мусора
 
 Еще одна перегруженная версия принимает еще и второй параметр - перечисление GCCollectionMode. Это перечисление может принимать три значения:

 Default: значение по умолчанию для данного перечисления (Forced)

 Forced: вызывает немедленное выполнение сборки мусора

 Optimized: позволяет сборщику мусора определить, является ли текущий момент оптимальным для сборки мусора
}
Потоки (streams) и файлы
98) Что такое поток (stream)?
99) Что такое FileStream?
100) Для чего нужен StreamReader?
101) Для чего нужен StreamWriter?
102) Для чего нужен BinaryReader?
103) Для чего нужен BinaryWriter?
104) Для чего нужен MemoryStream?
105) Что такое сериализация?
106) Какие виды сериализации вы знаете?
107) В чем отличие бинарной, XML, JSON сериализации?

Прочее
108) Для чего нужно ключевое слово yield?
109) Объясните принцип работы цикла foreach.
110) Как работает ключевое слово new при создании объекта класса или структуры?
111) Как хранятся в памяти массивы?
112) В чем особенности структур в С#?
113) Что такое readonly и ref структуры?
114) Какие методы находятся в классе Object?
{
 *toString
 Метод ToString служит для получения строкового представления данного объекта. Для базовых типов просто будет выводиться их строковое значение:
 *GetHashCode 
 Метод GetHashCode позволяет возвратить некоторое числовое значение, которое будет соответствовать данному объекту или его хэш-код. По данному числу, например, можно сравнивать объекты. Можно определять самые разные алгоритмы генерации подобного числа или взять реализаци базового типа:
 *Получение типа объекта и метод GetType
 
 Метод GetType позволяет получить тип данного объекта: 
 Person person = new Person { Name = "Tom" };
Console.WriteLine(person.GetType());    // Person  

 *Метод Equals
 Метод Equals позволяет сравнить два объекта на равенство:
}
115) Что такое значимый тип (ValueType)?
116) Для чего нужен ToString?
117) Для чего нужен метод Equals?
118) Для чего нужен метод GetHashCode?
119) Для чего нужен метод MemberwiseClone?
120) Для чего нужен метод GetType?
121) Что такое регулярное выражение?
{
 Регулярные выражения представляют эффективный и гибкий метод по обработке больших текстов, 
 позволяя в то же время существенно уменьшить объемы кода по сравнению с использованием стандартных операций
 со строками.

}
122) Что такое атрибут?
123) Что такое LINQ?
124) Какие методы из библиотеки LINQ вы знаете?
125) В чем отличие между query и method syntax в LINQ?
126) Для чего нужен класс Span<T>?
127) Для чего нужен класс Lazy<T>?
