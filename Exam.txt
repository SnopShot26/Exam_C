Платформа .Net
1) Что такое платформа .Net? 
{
 Когда говорят C#, нередко имеют в виду технологии платформы .NET (Windows Forms, WPF, ASP.NET, Xamarin). 
 И, наоборот, когда говорят .NET, нередко имеют в виду C#. Однако, хотя эти понятия связаны, отождествлять их неверно. 
 Язык C# был создан специально для работы с фреймворком .NET, однако само понятие .NET несколько шире
 *Поддержка нескольких языков
 *Кроссплатформенность.
 *Мощная библиотека классов
 *Производительность
}
2) В чем разница между .Net Framework и .Net Core?
{
 .NET Core работает в Linux и macOS, а .NET Framework работает только в Windows. 
 Вы бы использовали .NET Core, когда вам нужна кросс-платформенная совместимость, и вы бы использовали .NET Framework, 
 когда вам нужны специальные службы Windows и пакеты NuGet, которые не были перенесены в .NET Core. 
}
3) В чем заключаются основные отличия C# и C++?
4) Как отличается процесс компиляции и выполнения программы, написанной на C++ и C#?
5) Какие языки входят в .Net?
{
 наряду с C# это также VB.NET, C++, F#, 
 а также различные диалекты других языков, привязанные к .NET, например, Delphi.NET.
}
6) Из каких основных компонентов состоит .Net?
7) В чем заключаются преимущества .Net перед C++?
8) В чем заключаются недостатки .Net перед C++?
9) Что такое CLR (Common Language Runtime)?
{
  NET предоставляет среду выполнения (среду CLR), 
  которая выполняет код и предлагает службы, облегчающие процесс разработки.
  Компиляторы и иные средства позволяют использовать функции среды CLR и дают 
  разработчикам возможность писать код, использующий преимущества этой среды управляемого  выполнения. 
  Код,разработанный с использованием языкового компилятора для среды выполнения, называют управляемым. 
  В нем используются преимущества таких средств, как объединение языков  программирования, объединенная обработка исключений, усиленная безопасность, 
  поддержка отслеживания версий и развертывания, упрощенная модель взаимодействия компонентов, а также службы отладки и профилирования.
  
}
10) Что такое JIT (Just In Time) Compiler?
{
  это модуль в CLR который переводит IL-COD в машинный код;
}
11) Что такое GC (Garbage Collector)?
{
   Мусорщик который подчищает за нами;
}
12) Что такое BCL (Base Class Library) / FCL (Framework Class Library)?
{
  Base Class Library, или так называемая .NET FCL (англ. Framework Class Library), сокращённо BCL — стандартная библиотека классов платформы «.NET Framework».
  Программы,   написанные на любом из языков, поддерживающих платформу .NET, могут
  пользоваться классами и методами BCL — создавать объекты классов, вызывать их методы, наследовать необходимые классы BCL и т. д.
  Стоит отметить, что не все языки, поддерживающие платформу .NET, предоставляют или обязаны предоставлять одинаково полный доступ ко всем 
  классам и всем возможностям BCL — это зависит от особенностей реализации конкретного компилятора и языка. 
}
13) Что такое CTS (Common Type System)?
{
  Система общих типов 
  Система общих типов CTS определяет способ объявления, использования и управления типами в среде CLR,
  а также является важной составной частью поддержки межъязыковой интеграции  в среде выполнения. Система общих типов выполняет следующие функции.
  
      Формирует инфраструктуру, которая позволяет обеспечивать межъязыковую интеграцию, безопасность типов и высокопроизводительное выполнение кода.
  
      Предоставляет объектно-ориентированную модель, поддерживающую полную реализацию многих языков программирования.
  
      Определяет правила, которых необходимо придерживаться в языке. Эти правила помогают обеспечить взаимодействие объектов, написанных на разных языках.
  
      Предоставляет библиотеку, которая содержит типы-примитивы (например, Boolean, Byte, Char, Int32 и UInt64), используемые в разработке приложений.
}
14) Что такое CLS (Common Language System)? //Спросить У Амирана
{
 набор правил для ваше языка по которым он он должен компилироватся 
}
Сборка .Net приложений
15) Что такое сборка (assembly)?
16) Что такое MS-IL (Microsoft Intermediate Language)?
{
 промижуточный язык 
}
17) Что такое манифест (manifest)?
{
 там храниться данные проекта и его настройки 
}
18) Что такое метаданные (metadata)?
{
 они хранят описание данных классов , структур 
}
19) Что такое рефлексия (reflection)?
20) Что такое рефлектор (reflector)?
{ 
 расшифровывает Il cod
}
21) Что такое дотфускатор (dotfuscator)?
{
 запутывает Il код чтобы рефлектор не мог расшифрровать
}
22) В чем отличие управляемого кода от неуправляемого кода?

Типы данных .Net
23) В чем отличие ссылочных и значимых типов данных?
{

}
24) Чем отличаются друг от друга классы и структуры?
25) Что такое object? Какие методы он содержит?
26) Что такое стек (stack), куча (heap) и управляемая куча (managed heap)?
27) Что такое анонимный тип?
{
 Ключевое слово var ссылается на тип неявным способом. Это псевдоним любого типа. Реальный тип определит компилятор C#. 
 Использование var никак не ухудшает производительность. Var это отличный (и вкусный) синтаксический "сахар". Он делает программы короче и проще для чтения. 
 Var может использоваться в коде методов и в теле циклов. Ключевое слово var может представлять любой тип, 
 и какой это будет тип определяется во время компиляции. После компиляции результат получится тот же  самый, как если бы тип был точно указан.
}
28) Что такое nullable-тип?
{
 Значение null по умолчанию могут принимать только объекты ссылочных типов. Однако в различных ситуациях бывает удобно, чтобы объекты числовых типов данных имели значение null, то есть были бы не определены. Стандартный пример - работа с базой данных, которая может содержать значения null. И мы можем заранее не знать, что мы получим из базы данных - какое-то определенное значение или же null. Для этого надо использовать знак вопроса ? после типа значений. Например: 
int? z = null;
bool? enabled = null;
Но фактически запись ? является упрощенной формой использования структуры System.Nullable<T>. Параметр T в угловых скобках представляет универсальный параметр, вместо которого в конкретной задача уже подставляется конкретный тип данных. Следующие виды определения переменных будут эквивалентны: 
int? z1 = 5;
bool? enabled1 = null;
Double?  d1 = 3.3;
 
Nullable<int> z2 = 5;
Nullable<bool> enabled2 = null;
Nullable<System.Double> d2 = 3.3;
 

}
29) В чем заключается особенности преобразования типов данных в .Net?
30) Что такое ref и out параметры? В чем между ними разница? 
{
 ref — позволяет передать ссылку на инициализированную переменную. 
 out — позволяет передать ссылку на неинициализированную переменную. 
 
 
  Они почти одинаковы - единственная разница в том, что переменную, которую вы передаете как параметр out ,
  не нужно инициализировать, но, передавая ее как параметр ref , она должна быть установлена на что-то.

  int x;
  Foo(out x); // OK

 int y;
 Foo(ref y); // Error: y should be initialized before calling the method
 //////////////
 Ref параметр предназначен для данных, которые могут быть изменены, out параметра-для данных, 
 которые являются дополнительным выходом для функции (например,   int.TryParse), которая уже использует возвращаемое значение для чего-то.
}
31) Что такое in параметр? В каких случаях стоит его применять?
{
 

}
32) Что такое ключевое слово params?
{
 Ключевое слово params позволяет передать изменяемое количество аргументов типа, указанного в создании аргумента метода, с разделителями-запятыми, или массив аргументов указанного типа. Можно также не отправлять аргументы.

При создании метода после ключевого слова params дополнительные параметры не допускаются, и при создании метода допускается только одно ключевое слово params.

Пример использования метода у которого к параметру применено ключевое слово params:

static void ShowArray(string name, params int[] array)
{
    Console.Write(name);

    for (int i = 0; i < array.Length; i++)
    {
        Console.Write("{0} ", array[i]);
    }
    Console.WriteLine();
}

static void Main()
{
    int[] arr = new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    ShowArray("Numbers: ", arr);

    Console.WriteLine();

    ShowArray("Numbers: ", 0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
    
    Console.ReadKey();
}
}
33) Чем enum в .Net отличается от enum в C++?
34) Что такое упаковка и распаковка (boxing and unboxing)? Почему это плохо и как
его избежать?
{
 https://heap.tech/lore/id20 
}
35) В чем разница между классами String и StringBuilder?
{ 
 
В случае с классом String, когда выполняется операция присваивания =

// выделение памяти для строчного литерала "Text1"
string s = "Text1";

// перераспределение памяти (выделение нового участка)
s = "Text2";
память для нового строчного литерала («Text2») перераспределяется по новому: выделяется новый участок памяти, в который копируется новая измененная строка. Память, выделенная под предыдущий фрагмент, в дальнейшем уничтожается сборщиком мусора (Garbage collector).

В классе StringBuilder при изменении строки-оригинала, память для новой строки выделяется только в случае, когда размер новой строки больше размера строки-оригинала. При этом, памяти выделяется в два раза больше предыдущего размера. Если размер новой строки меньше или равен размеру строки-оригинала, то память не перераспределяется. Такой механизм позволяет повысить быстродействие за счет уменьшения интенсивности (количества) выделения новых ресурсов и освобождения использованных ресурсов.

Вывод: при интенсивной работе со строками рекомендуется использовать класс StringBuilder, в других случаях рекомендуется использовать класс String (или string).

}

Классы
36) Для чего нужны спецификаторы доступа у классов?
{
 Модификаторы доступа позволяют задать допустимую область видимости для членов класса. 
 То есть модификаторы доступа определяют контекст, 
 в котором можно употреблять данную переменную или метод 
}

37) Назовите все 6 видов спецификаторов доступа членов класса. Для чего они нужны?
{
public: публичный, общедоступный класс или член класса. 
Такой член класса доступен из любого места в коде, 
а также из других программ и сборок.

private: закрытый класс или член класса. Представляет полную противоположность модификатору public. 
Такой закрытый класс или член класса доступен только из кода в том же классе или контексте.

protected: такой член класса доступен из любого места в текущем классе или в производных классах. 
При этом производные классы могут располагаться в других сборках.

internal: класс и члены класса с подобным модификатором доступны из любого места кода в той же сборке, 
однако он недоступен для других программ и сборок (как в случае с модификатором public).

protected internal: совмещает функционал двух модификаторов. 
Классы и члены класса с таким модификатором доступны из текущей сборки и из производных классов.

private protected: такой член класса доступен из любого места в текущем классе или в производных классах, 
которые определены в той же сборке.

}

38) Для чего нужен статический конструктор? Когда он вызывается?
{
 Статический конструктор вызывается автоматически для инициализации
 класса перед созданием первого экземпляра 
 типа или ссылкой на какие-либо статические члены
}

39) Что такое делегирование конструкторов?
40) Что такое частичный класс (partial class)?
41) В чем отличие между константным и readonly полем?
{
 Постоянный член определяется во время компиляции и не может быть изменен во время выполнения. 
 Константы объявляются как поле, используя ключевое слово const и должны быть инициализированы по мере их объявления.

public class MyClass
{
    public const double PI1 = 3.14159;
}
A readonly член как константа в том, что он представляет неизменное значение. Разница в том, что элемент readonly может быть инициализирован во время выполнения, в конструкторе, а также может быть инициализирован по мере их объявления.

public class MyClass1
{
     public readonly double PI2 = 3.14159;

     //or

     public readonly double PI3;

     public MyClass2()
     {
         PI3 = 3.14159;
     }
}
}
42) Что такое свойство (property)?
43) Что такое авто-свойство (auto-property)?
44) Что такое индексатор?
45) Что такое итератор / энумиратор?
46) Для чего нужны пространства имен (namespaces)?
47) Что такое метод-расширение (extension method)?
48) Что такое обобщения (generics)?
49) Что такое правила обобщения (generics)? Какие правила вы знаете?

Наследование и полиморфизм
50) Опишите особенности наследования в .Net.
{
 По умолчанию все классы наследуются от базового класса Object, даже если мы явным образом не устанавливаем наследование. 
 Поэтому выше определенные классы Person и Employee кроме своих собственных методов, 
 также будут иметь и методы класса Object: ToString(), Equals(), GetHashCode() и GetType().

 Все классы по умолчанию могут наследоваться. Однако здесь есть ряд ограничений:

 * Не поддерживается множественное наследование, класс может наследоваться только от одного класса.

  * При создании производного класса надо учитывать тип доступа к базовому классу - тип доступа к производному классу должен быть таким же, как и у базового класса,     или более строгим. То есть, если базовый класс у нас имеет тип доступа internal, то производный класс может иметь тип доступа internal или private, 
    но не public.

   Однако следует также учитывать, что если базовый и производный класс находятся в разных сборках (проектах), 
   то в этом случае производый класс может наследовать     
   только от класса, который имеет модификатор public.

  *Если класс объявлен с модификатором sealed, то от этого класса нельзя наследовать и создавать производные классы. 
  Например, следующий класс не допускает создание наследников:

}
51) Для чего нужно ключевое слово base?
{
 Ключевое слово base используется для доступа к членам базового из производного класса в следующих случаях:
* Вызов метода базового класса, который был переопределен другим методом.
* Определение конструктора базового класса, который должен вызываться при создании экземпляров производного класса.
}
52) Что такое запечатанный класс (sealed class)?
{ 
 Запечатанный класс нельзя использовать в качестве базового класса.
 По этой причине он также не может быть абстрактным классом. 
 Запечатанные классы предотвращают наследование. 
 Поскольку они никогда не могут использоваться в качестве базового класса, 
 некоторые оптимизации времени выполнения могут немного ускорить вызов запечатанных членов класса.
}
53) Что такое абстрактный класс (abstract class)?
{

  // абстрактный класс фигуры
  abstract class Figure
  {
    // абстрактный метод для получения периметра
    public abstract float Perimeter();
    // абстрактный метод для получения площади
    public abstract float Area();
  }
  // производный класс прямоугольника
  class Rectangle : Figure
  {
    public float Width { get; set; }
    public float Height { get; set; }
 
    public Rectangle(float width, float height)
    {
        this.Width = width;
        this.Height = height;
    }
    // переопределение получения периметра
    public override float Perimeter()
    {
        return Width * 2 + Height * 2;
    }
    // переопрелеление получения площади
    public override float Area()
    {
        return Width * Height;
    }
 } 

}
54) В чем разница между виртуальным (virtual) и абстрактным (abstract) методов?
{
 Абстрактный метод не имеет реализации. Он объявлен в родительском классе. 
 Дочерний класс отвечает за реализацию этого метода.

 Виртуальный метод должен иметь реализацию в родительском классе, и это облегчает дочернему классу выбор, 
 использовать ли эту реализацию родительского класса или иметь новую реализацию для себя для этого 
 метода в дочернем классе.

}
55) В чем разница между переопределением (overriding) и перегрузкой (overloading)?
56) В чем разница между переопределением (overriding) и замещением (new)?
{
  overriding
  public class Base
  {
    public virtual void DoIt()
    {
    }
  }

  public class Derived : Base
  {
    public override void DoIt()
    {
    }
  }

  Base b = new Derived();
  b.DoIt();                      // Calls Derived.DoIt
  Новый модификатор указывает компилятору использовать вашу реализацию дочернего класса вместо реализации родительского класса . 
  Любой код, который не является ссылка на ваш класс, но родительский класс будет использовать реализацию родительского класса .
  
   New
   public class Base
  {
    public virtual void DoIt()
    {
    }
  }

  public class Derived : Base
  {
    public new void DoIt()
    {
    }
  }

  Base b = new Derived();
  Derived d = new Derived();

  b.DoIt();                      // Calls Base.DoIt
  d.DoIt();                      // Calls Derived.DoIt
  Фактически это два совершенно разных метода, которые имеют одно и то же имя, 
  а не производный метод, переопределяющий базовый метод.
}

Исключения
57) Объясните принцип работы try, catch.
58) Для чего нужно ключевое слово finally?
{
 метод который по люоому сработает;
}
59) Что делает конструкция using?
{
 это метод который раскрываеться воть так:
      try
      {
      }
      finally
      {
       Dispos();
      }
}
60) Для чего нужно ключевые слова checked и unchecked?
{
 Ключевое слово checked используется для явного включения проверки переполнения при выполнении арифметических операций и преобразований с данными целого типа.
 По умолчанию выражение, содержащее только константные значения, вызывает ошибку компилятора в том случае, если результат
 его вычисления выходит за допустимые пределы значений  конечного типа. Если выражение содержит одно или несколько 
 неконстантных значений, компилятор не выполняет проверку переполнения. 
 Вычисление выражения, присвоенного переменной i2 в приведенном ниже примере, не вызывает ошибку компилятора.
}

Интерфейсы
61) Что такое интерфейс?
{
 Интерфейс представляет ссылочный тип, который может определять некоторый функционал - набор методов и свойств без реализации. Затем этот функционал реализуют классы и структуры, которые применяют данные интерфейсы.
}
62) В чем отличие абстрактного класса от интерфейса?
{
 
Короткое различие.

Абстрактный класс — это класс, у которого не реализован один или больше методов (некоторые языки требуют такие методы помечать специальными ключевыми словами).

Интерфейс — это абстрактный класс, у которого ни один метод не реализован, все они публичные и нет переменных класса.

Интерфейс нужен обычно когда описывается только интерфейс (тавтология). Например, один класс хочет дать другому возможность доступа к некоторым своим методам, но не хочет себя «раскрывать». Поэтому он просто реализует интерфейс.

Абстрактный класс нужен, когда нужно семейство классов, у которых есть много общего. Конечно, можно применить и интерфейс, но тогда нужно будет писать много идентичного кода.

В некоторых языках (С++) специального ключевого слова для обозначения интерфейсов нет.

Можно считать, что любой интерфейс — это уже абстрактный класс, но не наоборот.


}
63) Что допустимо создавать в интерфейсе?
{
 В целом интерфейсы могут определять следующие сущности:

Методы

Свойства

Индексаторы

События

Статические поля и константы (начиная с версии C# 8.0)

Однако интерфейсы не могут определять нестатические переменные. Например, простейший интерфейс, который определяет все эти компоненты:
interface IMovable
{
    // константа
    const int minSpeed = 0;     // минимальная скорость
    // статическая переменная
    static int maxSpeed = 60;   // максимальная скорость
    // метод
    void Move();                // движение
    // свойство
    string Name { get; set; }   // название
     
    delegate void MoveHandler(string message);  // определение делегата для события
    // событие
    event MoveHandler MoveEvent;    // событие движения
}
}
64) Может ли интерфейс содержать реализацию методов?
{
 Стоит отметить, что если интерфейс имеет приватные методы и свойства (то есть с модификатором private), 
 то они должны иметь реализацию по умолчанию. 
 То же самое относится к любым статическим методам и свойствам (не обязательно приватным):
 interface IMovable
 {
    public const int minSpeed = 0;     // минимальная скорость
    private static int maxSpeed = 60;   // максимальная скорость
        // находим время, за которое надо пройти расстояние distance со скоростью speed
    static double GetTime(double distance, double speed) => distance / speed;
    static int MaxSpeed
    {
        get { return maxSpeed; }
        set
        {
            if (value > 0) maxSpeed = value;
        }
    }
 }
 class Program
 {
    static void Main(string[] args)
    {
        Console.WriteLine(IMovable.MaxSpeed);
        IMovable.MaxSpeed = 65;
        Console.WriteLine(IMovable.MaxSpeed);
        double time = IMovable.GetTime(100, 10);
        Console.WriteLine(time);
    }
 }
}
65) Что такое интерфейсная ссылка?
66) Что такое явная реализация интерфейса?
67) Какие стандартные интерфейсы вы знаете?
68) Для чего нужен интерфейс IComparable?
{
 Для сортировки наборов сложных объектов 
}
69) Для чего нужен интерфейс IClonable?
{
 то маркерный интерфейс, говорящий другим элементам программы о том, что объекты класса, реализующего этот интерфейс,
 можно клонировать. Вызывающий код может не знать, есть ли в этом классе конструктор копирования, 
 а в наличии метода Clone() для экземпляра IClonable можно не сомневаться.
}
70) Для чего нужен интерфейс IEnumerable?
{
  Вообще интерфейс IEnumerable представляет собой реализацию перечислителя.
  Конструкция foreach доступна нам благодаря этому интерфейсу
  (и в частности единственному методу, который в этом интерфейсе хранится - GetEnumerator(), который позволяет индексировать коллекцию).
}
71) Для чего нужен интерфейс IEnumerator?
{
 А интерфейс IEnumerator определяет функционал для перебора внутренних объектов в контейнере:
}
72) Для чего нужен интерфейс IDisposable?
{
 Интерфейс IDisposable объявляет один единственный метод Dispose, в котором при реализации интерфейса 
 в классе должно происходить освобождение неуправляемых    ресурсов
}
73) Для чего нужен интерфейс IEqualityComparer?
{
 Определяет методы для поддержки сравнения объектов на равенство.
}

Делегаты и события

74) Что такое делегат? Для чего нужны делегаты?
{
 Делегат в C# – это тип который содержит ссылку на какой-либо метод. 
 Делегаты удобны тем, что их можно передать в метод в качестве параметра.
 В общем виде объявление типа делегата выглядит так:
 using System;

class Program {
    // объявление типа делегата
    delegate void TestDelegateType();

    static void Main() {
        // создание экземпляра делегата TestDelegateType 
        TestDelegateType testDelegateInstance = new TestDelegateType( TargetMethod );
        // вызов метода из делегата
        testDelegateInstance();

        Console.ReadKey();
    }

    // Тестовый метод для передачи делегату TestDelegateType
    static void TargetMethod()
    {
        Console.WriteLine("Вызов из делегата.");
    }    
}
}
75) Что такое событие? Для чего нужны события?
{
   это сообщение, которое возникает в различных точках исполняемого кода при выполнении определённых условий.
}
76) В чем разница между делегатом и событием?
{
 Событие нельзя запустить вне класса, в котором оно было объявлено
 Делегат объявляется вне любого класса,а	Событие объявлено внутри класса
 Делегаты не зависят от событий,а	Событие не может быть создано без делегатов.
}
77) Что делает метод Invoke?
78) Что такое анонимный метод (anonymous method)?
{
 С делегатами тесно связаны анонимные методы. Анонимные методы используются для создания экземпляров делегатов. 
 Определение анонимных методов начинается с ключевого слова delegate, после которого идет в скобках список параметров и тело метода в фигурных скобках: 

 class Program
 {
    delegate void MessageHandler(string message);
    static void Main(string[] args)
    {
        MessageHandler handler = delegate(string mes)
        {
            Console.WriteLine(mes);
        };
        handler("hello world!");
 
        Console.Read();
    }
 }

}
79) Что такое лямбда-выражение (lambda-expression)?
{
 Лямбда-выражения представляют упрощенную запись анонимных методов. Лямбда-выражения позволяют создать емкие лаконичные методы, 
 которые могут возвращать некоторое   значение и которые можно передать в качестве параметров в другие методы.

 Ламбда-выражения имеют следующий синтаксис: слева от лямбда-оператора => определяется список параметров, а справа блок выражений, использующий эти параметры: (список_параметров) => выражение. Например:
 
  class Program
 {
    delegate int Operation(int x, int y);
    static void Main(string[] args)
    {
        Operation operation = (x, y) => x + y;
        Console.WriteLine(operation(10, 20));       
        Console.WriteLine(operation(40, 20));        
        Console.Read();
    }
 }
}

Коллекции
80) Какие необобщенные (non-generic) коллекции вы знаете?
81) Какие обобщенные (generic) коллекции вы знаете?
82) В чем преимущества обобщенных (generic) коллекций над необобщенными (non-generic)?
83) В чем разница между интерфейсами IEnumerable<T> и IEnumerator<T>?
84) Что такое ObservableCollection<T>? В чем отличие от List<T>?
85) Что такое IReadOnlyCollection<T> и IReadOnlyDictionary<T>?
86) В чем разница между IEnumerable<T>, ICollection<T> и IDictionary<K, V>?
87) В каких ситуациях следует использовать List<T>, LinkedList<T>, HashSet<T>,SortedSet<T>?
88) В чем отличие Dictionary<K,V>, SortedDictionary<K,V> и SortedList<K,V>?

Сборщик мусора (Garbage Collector)
89) Объясните принцип хранения объектов в памяти.
90) Зачем нужен сборщик мусора?
91) Что такое поколения?
92) Что такое граф объектов?
93) Что такое управляемые и неуправляемые ресурсы?
{
 правляемые ресурсы в основном означают "управляемую память", управляемую сборщиком мусора. Когда у вас больше нет ссылок на управляемый объект 
 (который использует  управляемую память), сборщик мусора (в конце концов) освободит эту память для вас.

 Неуправляемые ресурсы - это все, о чем не знает сборщик мусора. Например:

 Открыть файлы
 Открыть сетевые подключения
 Неуправляемая память
 В XNA: буферы вершин, буферы индексов, текстуры и т.д.
 Обычно вы хотите освободить эти неуправляемые ресурсы, прежде чем потерять все ссылки, которые у вас есть, на объект, управляющий ими. Вы делаете это, вызывая       Dispose на этом объекте или (в С#) с помощью инструкции using, которая будет обрабатывать вызов Dispose для вас.

}
94) Что такое финализатор?
{ 
Финализатор — это код, который автоматически выполняется непосредственно перед удалением объекта из памяти сборщиком мусора. 
Финализаторы используются для того, чтобы проверить, выполнена ли очистка объекта, и освободить дополнительную память, 
если она выделялась при создании или работе объекта в обход системы управления памятью.
Неквалифицированные программисты нередко пытаются применять финализаторы для освобождения файлов, сетевых сокетов и других системных ресурсов, 
используемых объектами. 

Это крайне плохая практика: 
поскольку момент удаления объекта сборщиком мусора зависит от объёма доступной памяти и интенсивности её использования  
программой, невозможно предсказать, когда будет вызван финализатор и будет ли он вызван вообще. 
Для освобождения любых системных ресурсов, кроме оперативной памяти,  финализаторы не подходят; 
программист должен вручную закрыть файлы или сокеты командой наподобие close(), 
когда объект реально перестаёт использоваться.

 он вызывваеться сборщиком мусора,
 финализатор похож на деструктор ,но они немного различаються :
 В C# и других языках сбора мусора вы не знаете, когда и даже будет ли выполнен финализатор.
 Однако в C++ вы знаете, когда и что деструктор выполняется, как только объект выходит за пределы области видимости.

}
95) Для чего нужен IDisposable.Dispose?
{
 Интерфейс IDisposable объявляет один единственный метод Dispose, в котором при реализации 
 интерфейса в классе должно происходить освобождение неуправляемых ресурсов
}
96) Что сборщик мусора делает с финализируемыми объектами?
97) Какие методы сборщика мусора вы знаеме?
{
 Метод AddMemoryPressure информирует среду CLR о выделении большого объема неуправляемой памяти, которую надо учесть при планировании сборки мусора. В связке с этим   методом используется метод RemoveMemoryPressure, который указывает CLR, что ранее выделенная память освобождена, и ее не надо учитывать при сборке мусора.

 Метод Collect приводит в действие механизм сборки мусора. Перегруженные версии метода позволяют указать поколение объектов, 
 вплоть до которого надо произвести  сборку мусора

 Метод GetGeneration(Object) позволяет определить номер поколения, к которому относится переданый в качестве параметра объект

 Метод GetTotalMemory возвращает объем памяти в байтах, которое занято в управляемой куче

 Метод WaitForPendingFinalizers приостанавливает работу текущего потока до освобождения всех объектов, для которых производится сборка мусора
 
 Еще одна перегруженная версия принимает еще и второй параметр - перечисление GCCollectionMode. Это перечисление может принимать три значения:

 Default: значение по умолчанию для данного перечисления (Forced)

 Forced: вызывает немедленное выполнение сборки мусора

 Optimized: позволяет сборщику мусора определить, является ли текущий момент оптимальным для сборки мусора
}
Потоки (streams) и файлы
98) Что такое поток (stream)?
{
 Он представляет байтовый поток и является базовым для всех остальных классов потоков.
 Stream определен набор членов, которые обеспечивают поддержку синхронного и асинхронного взаимодействия 
 с хранилищем (например, файлом или областью памяти). ... Концепция потока не ограничена файловым вводом-выводом.
}
99) Что такое FileStream?
{
 Чтение и запись файла Класс FileStream представляет возможности по считыванию из файла и записи в файл. 
 Он позволяет работать как с текстовыми файлами, так и с бинарными.
}
100) Для чего нужен StreamReader?
{
 служит для упрощения операций чтения текстовых файлов.

 Для примера использования класса StreamReader создадим на диске C:\ файл с именем example.txt, добавим туда одну строчку – example, и сохраним.

Теперь напишем программу для считывания этой строчки из файла:

using System;
using System.IO;
class Program
{
    static void Main()
    {
        StreamReader reader = new StreamReader( "C:\\example.txt" );
        
        // Чтение строки из StreamReader 
        string result = reader.ReadLine(); 
        
        Console.WriteLine(result);
        // Вывод: example
        reader.Close();   
    }

}
101) Для чего нужен StreamWriter?
{
 
Чтобы работать с файлом как хранилищем символов предназначены классы StreamWriter и StreamReader. 
Оба класса наследуются от TextWriter и TextReader соответственно, функционал которых расширен для работы с файловыми потоками.

}
102) Для чего нужен BinaryReader?
{
 Ему требуется, чтобы последовательность нулей и единиц преобразовывалась в изображения, текст или фильм. 
 Для записи в файловый поток или чтения из него данных в двоичном формате в платформе в пространстве имен 
 System.IO предусмотрены классы BinaryWriter и BinaryReader
 Классы BinaryReader и BinaryWriter инкапсулируют в себе поток. Их конструкторы при создании объекта принимают объект потока в качестве параметра, конструктор BinaryReader – входной поток, BinaryWriter – выходной. Это видно из сигнатур их простейших версий конструкторов:

BinaryWriter(Stream output)
BinaryReader(Stream imput)
Когда поток считывает или записывает двоичные данные в отличный от двоичного формат программист должен использовать расширенные версии конструктора:

BinaryWriter(Stream output, Encoding encoding)
BinaryReader(Stream imput, Encoding encoding)
Stream в сигнатуре метода означает поток. Поток, переданный конструктору должен быть открыт, иначе будет сгенерировано исключение. Соответственно после использование объекта над потоком (BinaryReader или BinaryWriter), поток нужно закрыть. Вызов метода Close (при котором неявно вызывается деструктор основного потока) освободит все ресурсы, связанные с потоком и завершит работу текущего объекта чтения или записи.

BinaryWriter BW = new BinaryWriter(new FileStream("C:/temp/Test/Configuratin.cfg",FileMode.Create));
Bw.Close();
Между моментом создания объекта одного из классов и завершением его через метод Close, программист должен реализовать инструкции записи/чтения в поток с помощью методов чтения или записи.

Для чтения в классе BinaryReader определен целый комплекс методов на каждый системный тип данных:

ReadByte;
ReadChar;
ReadDecimal;
ReadDouble;
ReadInt16, ReadInt32, ReadInt64;
ReadSingle;
ReadString;
И так далее.
BinaryWriter имеет аналогичные методы записи. Кроме того, в классе реализован метод Flush, который при вызове очищает все буферы, а все данные из них направляет на базовое устройство.

Классы применяются в программе в паре. Двоичные данные записанные в файл через обьект BinaryWriter, считываются через объект BinaryReader.
}
103) Для чего нужен BinaryWriter?
{
  102 вопрос
}
104) Для чего нужен MemoryStream?
{
 Данный класс представляет собой реализацию класса "Stream", в которой массив байтов используется для ввода и вывода. 
 Класс "MemoryStream" является полезным, 
 когда есть необходимость читать вводимые данные из массива или записывать выводимые данные в массив, 
 а не вводить их непосредственно из устройства или выводить прямо на   него. У данного класса имеется перегруженный конструктор.

 Наиболее употребительный вариант: 
 MemoryStream(byte[] buffer)
 "buffer" — это массив байтов, который является источником или приемником в запросах ввода (или вывода). 
  Тонкий момент: следует иметь ввиду, что для хранения  данных,   которые будут передаваться в массив "buffer", — он должен быть достаточно большим.

 Давайте на примере разберем, как работать с данным классом: 
 using System;
 using System.Text;
 using System.IO;
 namespace TestApplicationForStudy
{
  class Program
  {
    static void Main(string[] args)
    {
      byte[] data = new byte[255];
      // Создаём запоминающий поток
      MemoryStream mStream = new MemoryStream(data);
      // Создаём объекты чтения и записи данных в потоки
      // и передаём mStream в качестве параметра
      StreamReader sReader = new StreamReader(mStream);
      StreamWriter sWriter = new StreamWriter(mStream);
 
      // Записываем данные в память
      for (int i = 0; i < 10; i++)
      {
        sWriter.WriteLine("byte [" + i + "]: " + i);
      }
      // Записываем в память символ для того, чтобы в цикле
      // при достижении этого символа, выйти из цикла.
      // В противном случае мы пробежимся по всем 255 символам.
      sWriter.WriteLine("!");
      // Данный метод нужен для того, чтобы содержимое буфера этого объекта 
      // записалось непосредственно в массив data.
      // Если этого не сделать, то в массиве data ничего не будет.
      sWriter.Flush();
 
      // Читаем данные прямо из массива data.
      Console.WriteLine("Данные из массива data:");
      foreach (char ch in data)
      {
        if (ch == '!') break;
        Console.Write(ch);
      }
 
      // Читаем данные из потока с помощью StreamReader
      Console.WriteLine("Читаем данные из потока MemoryStream:");
      // Ставим указатель файла в начала запоминающего потока MemoryStream.
      // Если этого не сделать, то вывод будет пустым.
      mStream.Seek(0, SeekOrigin.Begin);
      string str = "";
      while ((str = sReader.ReadLine()) != null)
      {
        if (str == "!") break;
        Console.WriteLine(str);
 
      }
      Console.ReadLine();
    }
  }
 }
}
105) Что такое сериализация?
{
 Сериализация представляет процесс преобразования какого-либо объекта в поток байтов.
 А при необходимости можно выполнить обратный процесс - десериализацию, то есть получить из потока байтов ранее сохраненный объект.
}
106) Какие виды сериализации вы знаете?
107) В чем отличие бинарной, XML, JSON сериализации?

Прочее
108) Для чего нужно ключевое слово yield?
{
 yield — используется для перебора набора значений. Итератор использует две специальных инструкции: 

 yield return: определяет возвращаемый элемент. 

 yield break: указывает, что последовательность больше не имеет элементов.  
}
109) Объясните принцип работы цикла foreach.
{
 переьерает коллекции
}
110) Как работает ключевое слово new при создании объекта класса или структуры?
{
 MyClass foo;   //Создание ссылки. 

  MyClass foo = new MyClass();   //Создание объекта. 
}
111) Как хранятся в памяти массивы?
112) В чем особенности структур в С#?
{
 Но в отличие от класса нельзя инициализировать поля структуры напрямую при их объявлении, например, следующим образом: 
 struct User
 {
    public string name = "Sam";     // ! Ошибка
    public int age = 23;            // ! Ошибка
    public void DisplayInfo()
    {
        Console.WriteLine($"Name: {name}  Age: {age}");
    }
 }
 не могут наследоваться

}
113) Что такое readonly и ref структуры?
114) Какие методы находятся в классе Object?
{
 *toString
 Метод ToString служит для получения строкового представления данного объекта. Для базовых типов просто будет выводиться их строковое значение:


*GetHashCode 
 Метод GetHashCode позволяет возвратить некоторое числовое значение, которое будет соответствовать данному объекту или его хэш-код. 
 По данному числу, например,можно сравнивать объекты. Можно определять самые разные алгоритмы генерации подобного числа или взять реализаци базового типа:

*Получение типа объекта и метод GetType
 
 Метод GetType позволяет получить тип данного объекта: 
 Person person = new Person { Name = "Tom" };
 Console.WriteLine(person.GetType());    // Person  

 *Метод Equals
 Метод Equals позволяет сравнить два объекта на равенство:
}
115) Что такое значимый тип (ValueType)?
{
 Целочисленные типы (byte, sbyte, short, ushort, int, uint, long, ulong)

Типы с плавающей запятой (float, double)

Тип decimal

Тип bool

Тип char

Перечисления enum

Структуры (struct)

}
116) Для чего нужен ToString?
117) Для чего нужен метод Equals?
118) Для чего нужен метод GetHashCode?
119) Для чего нужен метод MemberwiseClone?//Amiran
120) Для чего нужен метод GetType?
121) Что такое регулярное выражение?
{
 Регулярные выражения представляют эффективный и гибкий метод по обработке больших текстов, 
 позволяя в то же время существенно уменьшить объемы кода по сравнению с использованием стандартных операций
 со строками.

}
122) Что такое атрибут?
123) Что такое LINQ?
124) Какие методы из библиотеки LINQ вы знаете?
125) В чем отличие между query и method syntax в LINQ?
126) Для чего нужен класс Span<T>?
127) Для чего нужен класс Lazy<T>?
